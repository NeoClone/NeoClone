unit eventQueue;

interface

uses
  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,
  Dialogs, PriorityQueue;

type
  TWatchDog = class(TThread)
  public

  protected
    procedure Execute; override;
  end;

  TQueueExecutor = class(TThread)
  public
    FEvent: TEvent;
    FRunningEvent: boolean;
  protected
    procedure Execute; override;
  end;

  TEventQueue = class
  private

  public
    function insert( event: TEvent ): integer;
  published
    constructor Create; overload;
    destructor Destroy; override;
  end;

var
  FPriorityQueue: TPriorityQueue;
  FQueueExecutor: TQueueExecutor;
  FWatchDog: TWatchDog;

implementation

uses
  unit1;

{
  Ten sposób zabijania threadu jest totalnie g³upi i powoduje memory leaki...
  oby to nie przeszkadza³o na d³u¿sz¹ metê...

  jak bedzie przeszkadzac, powodowac problemy to oddzielimy eventy na pare threadów

  - leczenie 1 thread
  - atakowanie 2 thread
  - lootowanie i skrypty 3 thread...

  ale to w koniecznosci
}

procedure TWatchDog.Execute;
var
  delCount, item: integer;
begin

  while not Terminated do
  begin
    sleep(1);
    // life time czyli jezeli event wykonuje sie za dlugo to zabija thread i tworzy od nowa
    if FQueueExecutor.FRunningEvent then
    begin
      if ((FQueueExecutor.FEvent.startTimeStamp + FQueueExecutor.FEvent.lifeTime) >= GetTickCount) then
      begin
        FQueueExecutor.FRunningEvent := false;
       // FQueueExecutor.Terminate;
        showmessage(booltostr(terminatethread(FQueueExecutor.Handle, 0)));
       // showmessage(inttostr(FQueueExecutor.FEvent.lifeTime) + ' >= ' + inttostr(FQueueExecutor.FEvent.startTimeStamp));
        //FQueueExecutor.Free;

        //FQueueExecutor := TQueueExecutor.Create(true);
        //FQueueExecutor.Start;
      end;
    end;

    {synchronize(
        procedure
        var
          i: integer;
        begin

          if FPriorityQueue.countEvents > 0 then
          begin
            for i := 0 to FPriorityQueue.countEvents-1 do
            begin
              if ((GetTickCount + FPriorityQueue.FQueue[i].expireTime) >= FPriorityQueue.FQueue[i].addTimeStamp) then
              begin
                FPriorityQueue.FQueue[i].shuffledDeletion := true;
              end;
            end;

            {
              chyba da siê to zrobiæ inaczej, np:
              pobraæ tablice index shuffledDeletion potem
              z kazdym delete odejmowac -1 do indexu(counta)

              musze to przemyœleæ
            }
           { delCount := FPriorityQueue.CountShuffledDeletion();
            for i := 0 to delCount-1 do
            begin
              item := FPriorityQueue.GetFirstShuffledDeletion();
              FPriorityQueue.delete( item );
            end;

          end;

        end
    );   }

  end;

end;

procedure TQueueExecutor.Execute;
var
  dummy: TEvent;
begin

  while not Terminated do
  begin
    FEvent := dummy;
    FRunningEvent := false;
    sleep(1);
    if FPriorityQueue.countEvents > 0 then
    begin
      synchronize(
        procedure
        begin
          FEvent := FPriorityQueue.pop();
          FEvent.startTimeStamp := GetTickCount;
        end
      );
      FRunningEvent := true;
      LuaScript.DoString( FEvent.script );
    end;
  end;

end;

constructor TEventQueue.Create;
begin
  inherited;
  FQueueExecutor := TQueueExecutor.Create(true);
  FWatchDog := TWatchDog.Create(true);
  FPriorityQueue := TPriorityQueue.Create;
  FQueueExecutor.Start;
  FWatchDog.Start;
end;

destructor TEventQueue.Destroy;
begin
  FWatchDog.Free;
  FPriorityQueue.Free;
  FQueueExecutor.Free;
  inherited;
end;

function TEventQueue.insert( event: TEvent ): integer;
begin
  event.addTimeStamp := GetTickCount;
  result := FPriorityQueue.insert( event );

  if (FQueueExecutor.FRunningEvent) and (event.overridePriority >= FQueueExecutor.FEvent.priority) then
  begin
    FQueueExecutor.Terminate;
    terminatethread(FQueueExecutor.Handle, 0);
    FQueueExecutor.Free;

    FQueueExecutor := TQueueExecutor.Create(true);
    FQueueExecutor.Start;
  end;

end;

end.
