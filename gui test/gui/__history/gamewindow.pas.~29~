unit gamewindow;

interface

uses
  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,
  Dialogs, StdCtrls, Addresses, map;

type
  TGameWindow = class
  private

    FMap: TMap;

  public

    function getSize(): TRect;
    function absoluteToCursor( x,y: integer ): TRect;

  published
    constructor Create; overload;
    destructor Destroy; override;
  end;

implementation

uses
  Unit1;

constructor TGameWindow.Create;
begin
  inherited;

  FMap := TMap.Create;
end;

destructor TGameWindow.Destroy;
begin
  FMap.Free;

  inherited;
end;

function TGameWindow.getSize(): TRect;
var
  tmp, i: integer;
begin
  tmp := Memory.ReadPointer( Addresses.guiPointer, [ $30, $24 ] ); // game window (map)

  result.Left := Memory.ReadInteger( tmp + $14);
  result.Top := Memory.ReadInteger( tmp + $18);
  result.Right := Memory.ReadInteger( tmp + $1c);
  result.Bottom := Memory.ReadInteger( tmp + $20);
end;

function TGameWindow.absoluteToCursor( x,y: integer ): TRect;
var
  r: TRect;
  player: TPoint;
  tileWidth, tileHeight: integer;
begin

  r := getSize();
  player.X := Memory.ReadInteger( addresses.selfX );
  player.Y := Memory.ReadInteger( addresses.selfY );

  tileWidth := round( r.Right / 15 );
  tileHeight := round( r.Bottom / 11 );

  player.X := player.X - 7; // x lewego górnego rogu
  player.Y := player.Y - 5; // y lewego górnego rogu

  result.Left := x - player.X;
  result.Top := y - player.Y;

  result.Left := (tileWidth * result.Left);
  result.Top := (tileHeight * result.Top);
  result.Right := tileWidth;
  result.Bottom := tileHeight;

end;

end.
