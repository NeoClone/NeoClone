unit settingsForm;

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,
  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, VirtualTrees, XML.VerySimple,
  Vcl.StdCtrls, Vcl.Samples.Spin, settingsTemplates, settingsHelper;

type

  TPropertyEditLink = class(TInterfacedObject, IVTEditLink)
  private
    FEdit: array[0..7] of TWinControl;        // One of the property editor classes.
    FEditCount: integer;
    FTree: TVirtualStringTree; // A back reference to the tree calling.
    FNode: PVirtualNode;       // The node being edited.
    FColumn: Integer;          // The column of the node being edited.
  protected

  public
    destructor Destroy; override;

    function BeginEdit: Boolean; stdcall;
    function CancelEdit: Boolean; stdcall;
    function EndEdit: Boolean; stdcall;
    function GetBounds: TRect; stdcall;
    function PrepareEdit(Tree: TBaseVirtualTree; Node: PVirtualNode; Column: TColumnIndex): Boolean; stdcall;
    procedure ProcessMessage(var Message: TMessage); stdcall;
    procedure SetBounds(R: TRect); stdcall;
  end;

  TsettingsForm = class(TForm)
    PropTree: TVirtualStringTree;
    procedure FormCreate(Sender: TObject);
    procedure PropTreeGetText(Sender: TBaseVirtualTree; Node: PVirtualNode;
      Column: TColumnIndex; TextType: TVSTTextType; var CellText: string);
    procedure PropTreeCreateEditor(Sender: TBaseVirtualTree; Node: PVirtualNode;
      Column: TColumnIndex; out EditLink: IVTEditLink);
    procedure PropTreeEditing(Sender: TBaseVirtualTree; Node: PVirtualNode;
      Column: TColumnIndex; var Allowed: Boolean);
    procedure PropTreeNodeDblClick(Sender: TBaseVirtualTree;
      const HitInfo: THitInfo);
    procedure newItemClick(Sender: TObject);
    procedure deleteItemClick(Sender: TObject);
    procedure EditSpinChange(Sender: TObject);
  private
    { Private declarations }
  public
    procedure RecursivePropTree( node: PVirtualNode; xmlNode: TXmlNode; first: boolean = false );
    function FindSettingValue( arr: array of string; node: PVirtualNode ): string;
    function FindNode( node: PVirtualNode; name: string ): PVirtualNode;
    function FindNodeEx( name: string; index: integer = -1 ): PVirtualNode;
  end;

var
  settingsForm: TsettingsForm;
  settings: TVerySimpleXML;
implementation

{$R *.dfm}

//----------------------------------------------------------------------------------------------------------------------


function getsetting( path: string ): string;
var
  expl: TExplodeArray;
  i, d: integer;
  arr: array of string;
  str: string;
begin

  result := '';

  expl := explode( '/', path );
  setlength( arr, length(expl) );
  d := length(expl)-1;
  for str in expl do
  begin
    arr[d] := str;
    dec(d);
  end;

  result := settingsForm.FindSettingValue( arr, settingsForm.PropTree.RootNode.FirstChild)
end;


destructor TPropertyEditLink.Destroy;
var
  i: integer;
begin
  for i := 0 to FEditCount-1 do
  begin
    FEdit[i].Free;
  end;
  inherited;
end;

function TPropertyEditLink.BeginEdit: Boolean;
var
  i: integer;
begin
  Result := True;
  for i := 0 to FEditCount-1 do
  begin
    FEdit[i].Show;
    FEdit[i].SetFocus;
  end;
end;

function TPropertyEditLink.CancelEdit: Boolean;
var
  i: integer;
begin
  Result := True;
  for i := 0 to FEditCount-1 do
  begin
    FEdit[i].Hide;
  end;
end;

function TPropertyEditLink.EndEdit: Boolean;
var
  Data: ^TTreeData;
  P: TPoint;
  Dummy, i: Integer;
begin
  // Check if the place the user click on yields another node as the one we
  // are currently editing. If not then do not stop editing.
  GetCursorPos(P);
  P := FTree.ScreenToClient(P);
  Result := FTree.GetNodeAt(P.X, P.Y, True, Dummy) <> FNode;

  if Result then
  begin

    Data := FTree.GetNodeData(FNode);

    if FColumn = 1 then
    begin
      case Data.dataType of

        xdInteger:
          begin
            data.value := (FEdit[0] as TSpinEdit).Text;
          end;

        xdBoolean:
          begin
            data.value := (FEdit[0] as TComboBox).Text;
          end;

        xdComboBox:
          begin
            data.value := (FEdit[0] as TComboBox).Text;
          end;

        xdRange:
          begin

            data.value := inttostr((FEdit[0] as TSpinEdit).value) + ' ';

            if (FEdit[0] as TSpinEdit).Value > 0 then
            begin
              if ((FEdit[1] as TSpinEdit).Value = 0) then
              begin
                data.value := data.value + 'and above';
              end
              else
              begin
                data.value := data.value + 'to ' + inttostr((FEdit[1] as TSpinEdit).value);
              end;
            end
            else
            begin
              data.value := data.value + 'to ' + inttostr((FEdit[1] as TSpinEdit).value);
            end;

          end;

        xdRangePercent:
          begin

            data.value := inttostr((FEdit[0] as TSpinEdit).value) + ' ';

            if (FEdit[0] as TSpinEdit).Value > 0 then
            begin
              if ((FEdit[1] as TSpinEdit).Value = 0) then
              begin
                data.value := data.value + 'and above';
              end
              else
              begin
                data.value := data.value + 'to ' + inttostr((FEdit[1] as TSpinEdit).value);
              end;
            end
            else
            begin
              data.value := data.value + 'to ' + inttostr((FEdit[1] as TSpinEdit).value);
            end;

            if (FEdit[2] as TComboBox).Text = 'percent' then
              data.value := data.value + ' %';

          end;

      end;
    end
    else
    begin
      data.name := (FEdit[0] as TEdit).Text;
    end;

    for i := 0 to FEditCount-1 do
      FEdit[i].Hide;
  end;
end;

function TPropertyEditLink.GetBounds: TRect;
begin
  Result := FEdit[0].BoundsRect;
end;

function TPropertyEditLink.PrepareEdit(Tree: TBaseVirtualTree; Node: PVirtualNode; Column: TColumnIndex): Boolean;
var
  Data: ^TTreeData;
  i: integer;
  tmp: array[0..10] of string;
  percent, above: boolean;
begin
  Result := True;
  FTree := Tree as TVirtualStringTree;
  FNode := Node;
  FColumn := Column;

  for i := 0 to FEditCount-1 do
  begin
    FEdit[i].Free;
    FEdit[i] := nil;
  end;

  Data := FTree.GetNodeData(Node);

  if Column = 1 then
  begin
    case Data.dataType of

      xdInteger:
        begin
          FEditCount := 1;
          FEdit[0] := TSpinEdit.Create(nil);
          with FEdit[0] as TSpinEdit do
          begin
            Visible := False;
            Parent := Tree;
            Text := Data.Value;
            width := 60;
            OnChange := settingsForm.EditSpinChange;
          end;
        end;

      xdBoolean:
        begin
          FEditCount := 1;
          FEdit[0] := TCombobox.Create(nil);
          with FEdit[0] as TCombobox do
          begin
            Style := csDropDownList;
            Visible := False;
            Parent := Tree;
            Items.Add('no');
            Items.Add('yes');
            ItemIndex := FindIndex( (FEdit[0] as TCombobox), Data.value );
          end;
        end;

      xdRange:
        begin
          tmp[0] := copy(Data.value, 1, pos(' ', Data.value) - 1);
          above := (pos('above', Data.value) > 0);

          if above then
            tmp[1] := '0'
          else
            tmp[1] := copy(Data.value, pos('to ', Data.value) + 3, length(Data.value));

          FEditCount := 2;
          FEdit[0] := TSpinEdit.Create(nil);
          with FEdit[0] as TSpinEdit do
          begin
            Visible := False;
            Parent := Tree;
            Text := tmp[0];
            width := 60;
            OnChange := settingsForm.EditSpinChange;
          end;

          FEdit[1] := TSpinEdit.Create(nil);
          with FEdit[1] as TSpinEdit do
          begin
            Visible := False;
            Parent := Tree;
            Text := tmp[1];
            width := 60;
            OnChange := settingsForm.EditSpinChange;
          end;
        end;

        xdRangePercent:
        begin
          tmp[0] := copy(Data.value, 1, pos(' ', Data.value) - 1);
          percent := (pos('%', Data.value) > 0);
          above := (pos('above', Data.value) > 0);

          if above then
            tmp[1] := '0'
          else
            tmp[1] := copy(Data.value, pos('to ', Data.value) + 3, length(Data.value));

          if percent then
            delete(tmp[1], pos(' %', tmp[1]), 2);

          FEditCount := 3;
          FEdit[0] := TSpinEdit.Create(nil);
          with FEdit[0] as TSpinEdit do
          begin
            Visible := False;
            Parent := Tree;
            Text := tmp[0];
            width := 60;
            OnChange := settingsForm.EditSpinChange;
          end;

          FEdit[1] := TSpinEdit.Create(nil);
          with FEdit[1] as TSpinEdit do
          begin
            Visible := False;
            Parent := Tree;
            Text := tmp[1];
            width := 60;
            OnChange := settingsForm.EditSpinChange;
          end;

          FEdit[2] := TCombobox.Create(nil);
          with FEdit[2] as TCombobox do
          begin
            Style := csDropDownList;
            Visible := False;
            Parent := Tree;
            Items.Add('exact');
            Items.Add('percent');

            if percent then
              ItemIndex := 1
            else
              ItemIndex := 0;

            Width := 60;
          end;
        end;

      xdComboBox:
        begin
          FEditCount := 1;
          FEdit[0] := TCombobox.Create(nil);
          with FEdit[0] as TCombobox do
          begin
            Style := csDropDownList;
            Visible := False;
            Parent := Tree;
            ComboAddItems( (FEdit[0] as TCombobox), Data.name );
            ItemIndex := FindIndex( (FEdit[0] as TCombobox), Data.value );
            Height := Node.NodeHeight;
          end;
        end;

      xdList:
        begin
          FEditCount := 1;
          FEdit[0] := TButton.Create(nil);
          with FEdit[0] as TButton do
          begin
            Visible := False;
            Parent := Tree;
            Height := Node.NodeHeight;
            Caption := '{ new }';
            OnClick := settingsForm.newItemClick;
          end;
        end;

      xdSubitem:
        begin
          FEditCount := 1;
          FEdit[0] := TButton.Create(nil);
          with FEdit[0] as TButton do
          begin
            Visible := False;
            Parent := Tree;
            Height := Node.NodeHeight;
            Caption := '{ remove }';
            OnClick := settingsForm.deleteItemClick;
          end;
        end

        else
        begin
          FEditCount := 1;
          FEdit[0] := TEdit.Create(nil);
          with FEdit[0] as TEdit do
          begin
            Visible := False;
            Parent := Tree;
            Text := Data.Value;
            //OnKeyDown := EditKeyDown;
          end;
        end;

    end;
  end
  else
  begin
    FEditCount := 1;
    FEdit[0] := TEdit.Create(nil);
    with FEdit[0] as TEdit do
    begin
      Visible := False;
      Parent := Tree;
      Text := Data.name;
      //OnKeyDown := EditKeyDown;
    end;
  end;

end;


procedure TPropertyEditLink.ProcessMessage(var Message: TMessage);
var
  i: integer;
begin
  for i := 0 to FEditCount-1 do
    FEdit[i].WindowProc(Message);
end;


procedure TPropertyEditLink.SetBounds(R: TRect);
var
  Dummy: Integer;
begin
  FTree.Header.Columns.GetColumnBounds(FColumn, Dummy, R.Right);

  if (FEdit[0] is TEdit) or (FEdit[0] is TComboBox) then
  begin
    FEdit[0].BoundsRect := R;
    exit;
  end;

  if (FEdit[0] is TButton) then
  begin
    r.Right := R.Left + 100;
    FEdit[0].BoundsRect := R;
    exit;
  end;

  r.Right := R.Left + FEdit[0].Width;
  FEdit[0].BoundsRect := R;

  if Assigned(FEdit[1]) then
  begin
    r.Left := r.Left + FEdit[0].Width + 1;
    r.Right := r.Left + FEdit[1].Width;
    FEdit[1].BoundsRect := R;
  end;

  if Assigned(FEdit[2]) then
  begin
    r.Left := r.Left + FEdit[1].Width + 1;
    r.Right := r.Left + FEdit[2].Width;
    FEdit[2].BoundsRect := R;
  end;

end;

//----------------------------------------------------------------------------------------------------------------------

procedure TsettingsForm.deleteItemClick(Sender: TObject);
begin

  PropTree.DeleteNode( PropTree.FocusedNode );

end;


procedure TsettingsForm.newItemClick(Sender: TObject);
var
  node, fnode: PVirtualNode;
  nodeData: ^TTreeData;
  xmlItem: TVerySimpleXML;
  name: string;
  i: Integer;
begin

  node := PropTree.FocusedNode;
  nodeData := PropTree.GetNodeData( node );

  xmlItem := TVerySimpleXML.Create;
  case StringToCaseSelect(nodeData.name, ['ItemList', 'HealRules', 'HotkeyList',
                                          'PersistentList', 'CavebotList', 'DisplaysList',
                                          'Monsters']) of

    0: // ItemList
      begin
        xmlItem.LoadFromString( loadCleanNewItem() );

        for i := 1 to 1000 do
        begin
          name := xmlItem.Root.NodeName;
          delete(name, 1, 1);
          name := name + inttostr(i);

          if not assigned( FindNode( node.FirstChild, name ) ) then
          begin
            xmlItem.Root.NodeName := 'e' + name;
            break;
          end;
        end;
      end;

    1: // HealRules
      begin
        xmlItem.LoadFromString( LoadCleanNewRule() );

        for i := 1 to 1000 do
        begin
          name := xmlItem.Root.NodeName;
          delete(name, 1, 1);
          name := name + inttostr(i);

          if not assigned( FindNode( node.FirstChild, name ) ) then
          begin
            xmlItem.Root.NodeName := 'e' + name;
            break;
          end;
        end;
      end;

    2: // HotkeyList
      begin
        xmlItem.LoadFromString( loadCleanNewHotkey() );

        for i := 1 to 1000 do
        begin
          name := xmlItem.Root.NodeName;
          delete(name, 1, 1);
          name := name + inttostr(i);

          if not assigned( FindNode( node.FirstChild, name ) ) then
          begin
            xmlItem.Root.NodeName := 'e' + name;
            break;
          end;
        end;
      end;

    3: // PresistantList
      begin
        xmlItem.LoadFromString( loadCleanNewPersistent() );

        for i := 1 to 1000 do
        begin
          name := xmlItem.Root.NodeName;
          delete(name, 1, 1);
          name := name + inttostr(i);

          if not assigned( FindNode( node.FirstChild, name ) ) then
          begin
            xmlItem.Root.NodeName := 'e' + name;
            break;
          end;
        end;
      end;

    4: // Cavebot List
      begin
        xmlItem.LoadFromString( loadCleanNewCavebot() );

        for i := 1 to 1000 do
        begin
          name := xmlItem.Root.NodeName;
          delete(name, 1, 1);
          name := name + inttostr(i);

          if not assigned( FindNode( node.FirstChild, name ) ) then
          begin
            xmlItem.Root.NodeName := 'e' + name;
            break;
          end;
        end;
      end;

    5: // DisplaysList
      begin
        xmlItem.LoadFromString( loadCleanNewDisplay() );

        for i := 1 to 1000 do
        begin
          name := xmlItem.Root.NodeName;
          delete(name, 1, 1);
          name := name + inttostr(i);

          if not assigned( FindNode( node.FirstChild, name ) ) then
          begin
            xmlItem.Root.NodeName := 'e' + name;
            break;
          end;
        end;
      end;

    6: // Monsters
      begin
        xmlItem.LoadFromString( loadCleanNewMonster() );

        for i := 1 to 1000 do
        begin
          name := xmlItem.Root.NodeName;
          delete(name, 1, 1);
          name := name + inttostr(i);

          if not assigned( FindNode( node.FirstChild, name ) ) then
          begin
            xmlItem.Root.NodeName := 'e' + name;
            break;
          end;
        end;
      end;

  end;

  RecursivePropTree(node, xmlItem.Root);
  xmlItem.Free;
end;


function TsettingsForm.FindNode( node: PVirtualNode; name: string ): PVirtualNode;
var
  nodeData: ^TTreeData;
begin

  result := nil;
  nodeData := PropTree.GetNodeData( node );

  while assigned(nodeData) do
  begin

    if nodeData.name = name then
    begin
      result := node;
      break;
    end;

    node := node.NextSibling;
    nodeData := PropTree.GetNodeData( node );
  end;

end;


function TsettingsForm.FindNodeEx( name: string; index: integer = -1 ): PVirtualNode;
var
  xNode: PVirtualNode;
  nodeData: ^TTreeData;
begin

  result := nil;
  if not assigned(PropTree.GetFirst()) then exit;

  xNode := PropTree.GetFirst();
  repeat
    xNode := PropTree.GetNext( xNode );
    nodeData := PropTree.GetNodeData( xNode );

    if index = -1 then
    begin
      if ( nodeData.name = name ) then
      begin
        result := xNode;
        break;
      end;
    end
    else
    begin
      if index = xNode.Index then
      begin
        result := xNode;
        break;
      end;
    end;

  until xNode = PropTree.GetLast();

end;


function TsettingsForm.FindSettingValue( arr: array of string; node: PVirtualNode ): string;
var
  find, row: string;
  xNode: PVirtualNode;
  nodeData: ^TTreeData;
  xarr: array of string;
  i: Integer;
begin
  result := '';
  if length(arr) = 0 then
  begin
    nodeData := PropTree.GetNodeData( node );
    result := nodeData.value;
    exit;
  end;

  find := arr[ high(arr) ];

  setlength( xarr, length(arr) - 1 );
  for i := 0 to length(arr) - 2 do
    xarr[i] := arr[i];

  xNode := node.FirstChild;

  while Assigned(xNode) do
  begin

    nodeData := PropTree.GetNodeData( xNode );

    if lowercase(nodeData.name) = lowercase(find) then
    begin
      result := FindSettingValue( xarr, xNode );
      break;
    end;

    xNode := xNode.NextSibling;

  end;

end;

procedure TsettingsForm.RecursivePropTree( node: PVirtualNode; xmlNode: TXmlNode; first: boolean = false );
var
  xmlChildNode: TXmlNode;
  nodeData: ^TTreeData;
  i: integer;
  typ: Char;
begin

  if first then
    node := PropTree.AddChild( nil )
  else
  begin
    node := PropTree.AddChild( node );
  end;

  //node.NodeHeight := 20;
  nodeData := PropTree.GetNodeData( node );

  typ := xmlNode.NodeName[1];
  nodeData.name := xmlNode.NodeName;
  delete( nodeData.name, 1, 1 );

  case ord(typ) of

    ord('s'): // static
      begin
        nodeData.dataType := xdStatic;
        nodeData.value := '';
      end;

    ord('b'): // boolean
      begin
        nodeData.dataType := xdBoolean;
        nodeData.value := xmlNode.Text;
      end;

    ord('i'): // integer
      begin
        nodeData.dataType := xdInteger;
        nodeData.value := xmlNode.Text;
      end;

    ord('r'): // range
      begin
        nodeData.dataType := xdRange;
        nodeData.value := xmlNode.Text;
      end;

    ord('l'): // list
      begin
        nodeData.dataType := xdList;
        nodeData.value := '..';
      end;

    ord('u'): // text list
      begin
        nodeData.dataType := xdTextList;
        nodeData.value := StringReplace( xmlNode.Text, '&#xd;', #13, [rfReplaceAll] );
      end;

    ord('t'): // text
      begin
        nodeData.dataType := xdText;
        nodeData.value := xmlNode.Text;
      end;

    ord('w'): // waypoint
      begin
        nodeData.dataType := xdWayPoint;
        nodeData.value := xmlNode.Text;

        if length(nodeData.name) = 0 then
          nodeData.name := copy( nodeData.value, 1, pos(' ', nodeData.value)-1 );
      end;

    ord('c'): // combobox
      begin
        nodeData.dataType := xdComboBox;
        nodeData.value := xmlNode.Text;
      end;

    ord('x'): // range percent
      begin
        nodeData.dataType := xdRangePercent;
        nodeData.value := xmlNode.Text;
      end;

    ord('e'): // subitem
      begin
        nodeData.dataType := xdSubitem;
        nodeData.name := StringReplace( nodeData.name, '-', ' ', [rfReplaceAll] );
        nodeData.value := '..';
      end;

  end;

  if xmlNode.ChildNodes.Count > 0 then
  begin
    for i := 0 to  xmlNode.ChildNodes.Count-1 do
    begin
      xmlChildNode := xmlNode.ChildNodes.Items[i];
      RecursivePropTree( node, xmlChildNode );
    end;
  end;
end;


procedure TsettingsForm.EditSpinChange(Sender: TObject);
begin
  if (Sender as TSpinEdit).Text = '' then
    (Sender as TSpinEdit).Value := 0;
end;

procedure TsettingsForm.FormCreate(Sender: TObject);
begin

  settings := TVerySimpleXML.Create;
  settings.LoadFromString( loadCleanSettings() );

  PropTree.NodeDataSize := sizeof(TVirtualNode);
  RecursivePropTree(PropTree.RootNode, settings.Root, true);

end;

procedure TsettingsForm.PropTreeCreateEditor(Sender: TBaseVirtualTree;
  Node: PVirtualNode; Column: TColumnIndex; out EditLink: IVTEditLink);
begin
  EditLink := TPropertyEditLink.Create;
end;

procedure TsettingsForm.PropTreeEditing(Sender: TBaseVirtualTree; Node: PVirtualNode;
  Column: TColumnIndex; var Allowed: Boolean);
var
  Data: ^TTreeData;

begin
  with Sender do
  begin
    Data := GetNodeData(Node);

    if (Node.Parent <> RootNode) and (Column = 0) and (Data.dataType in [xdSubitem]) then
      Allowed := true
    else
      Allowed := (Node.Parent <> RootNode) and (Column = 1) and not (Data.dataType in [xdStatic]);
  end;
end;

procedure TsettingsForm.PropTreeGetText(Sender: TBaseVirtualTree; Node: PVirtualNode;
  Column: TColumnIndex; TextType: TVSTTextType; var CellText: string);
var
  nodeData: ^TTreeData;
begin
  nodeData := Sender.GetNodeData(node);
  if Column = 0 then
    CellText := nodeData.name
  else
  begin
    CellText := nodeData.value;
  end;
end;

procedure TsettingsForm.PropTreeNodeDblClick(Sender: TBaseVirtualTree;
  const HitInfo: THitInfo);
begin
  with Sender do
  begin
    // Start immediate editing as soon as another node gets focused.
    if Assigned(HitInfo.HitNode) and (HitInfo.HitNode.Parent <> RootNode) and not (tsIncrementalSearching in TreeStates) then
    begin
      // Note: the test whether a node can really be edited is done in the OnEditing event.
      EditNode(HitInfo.HitNode, 1);
    end;
  end;
end;

end.
